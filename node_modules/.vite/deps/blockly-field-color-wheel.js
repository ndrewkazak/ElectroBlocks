import {
  require_blockly
} from "./chunk-JEP3JAJ7.js";
import {
  __toESM
} from "./chunk-LNEMQRCO.js";

// node_modules/blockly-field-color-wheel/src/index.js
var import_blockly = __toESM(require_blockly());

// node_modules/@jaames/iro/dist/iro.es.js
var n;
var u;
var t;
var i;
var r;
var o;
var f = {};
var e = [];
var c = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;
function s(n2, l) {
  for (var u2 in l) {
    n2[u2] = l[u2];
  }
  return n2;
}
function a(n2) {
  var l = n2.parentNode;
  l && l.removeChild(n2);
}
function h(n2, l, u2) {
  var t2, i2, r2, o2, f2 = arguments;
  if (l = s({}, l), arguments.length > 3) {
    for (u2 = [u2], t2 = 3; t2 < arguments.length; t2++) {
      u2.push(f2[t2]);
    }
  }
  if (null != u2 && (l.children = u2), null != n2 && null != n2.defaultProps) {
    for (i2 in n2.defaultProps) {
      void 0 === l[i2] && (l[i2] = n2.defaultProps[i2]);
    }
  }
  return o2 = l.key, null != (r2 = l.ref) && delete l.ref, null != o2 && delete l.key, v(n2, l, o2, r2);
}
function v(l, u2, t2, i2) {
  var r2 = { type: l, props: u2, key: t2, ref: i2, __k: null, __p: null, __b: 0, __e: null, l: null, __c: null, constructor: void 0 };
  return n.vnode && n.vnode(r2), r2;
}
function d(n2) {
  return n2.children;
}
function y(n2) {
  if (null == n2 || "boolean" == typeof n2) {
    return null;
  }
  if ("string" == typeof n2 || "number" == typeof n2) {
    return v(null, n2, null, null);
  }
  if (null != n2.__e || null != n2.__c) {
    var l = v(n2.type, n2.props, n2.key, null);
    return l.__e = n2.__e, l;
  }
  return n2;
}
function m(n2, l) {
  this.props = n2, this.context = l;
}
function w(n2, l) {
  if (null == l) {
    return n2.__p ? w(n2.__p, n2.__p.__k.indexOf(n2) + 1) : null;
  }
  for (var u2; l < n2.__k.length; l++) {
    if (null != (u2 = n2.__k[l]) && null != u2.__e) {
      return u2.__e;
    }
  }
  return "function" == typeof n2.type ? w(n2) : null;
}
function g(n2) {
  var l, u2;
  if (null != (n2 = n2.__p) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l = 0; l < n2.__k.length; l++) {
      if (null != (u2 = n2.__k[l]) && null != u2.__e) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    }
    return g(n2);
  }
}
function k(l) {
  (!l.__d && (l.__d = true) && 1 === u.push(l) || i !== n.debounceRendering) && (i = n.debounceRendering, (n.debounceRendering || t)(_));
}
function _() {
  var n2, l, t2, i2, r2, o2, f2, e2;
  for (u.sort(function(n3, l2) {
    return l2.__v.__b - n3.__v.__b;
  }); n2 = u.pop(); ) {
    n2.__d && (t2 = void 0, i2 = void 0, o2 = (r2 = (l = n2).__v).__e, f2 = l.__P, e2 = l.u, l.u = false, f2 && (t2 = [], i2 = $(f2, r2, s({}, r2), l.__n, void 0 !== f2.ownerSVGElement, null, t2, e2, null == o2 ? w(r2) : o2), j(t2, r2), i2 != o2 && g(r2)));
  }
}
function b(n2, l, u2, t2, i2, r2, o2, c2, s2) {
  var h2, v2, p, d2, y2, m2, g2, k2 = u2 && u2.__k || e, _2 = k2.length;
  if (c2 == f && (c2 = null != r2 ? r2[0] : _2 ? w(u2, 0) : null), h2 = 0, l.__k = x(l.__k, function(u3) {
    if (null != u3) {
      if (u3.__p = l, u3.__b = l.__b + 1, null === (p = k2[h2]) || p && u3.key == p.key && u3.type === p.type) {
        k2[h2] = void 0;
      } else {
        for (v2 = 0; v2 < _2; v2++) {
          if ((p = k2[v2]) && u3.key == p.key && u3.type === p.type) {
            k2[v2] = void 0;
            break;
          }
          p = null;
        }
      }
      if (d2 = $(n2, u3, p = p || f, t2, i2, r2, o2, null, c2, s2), (v2 = u3.ref) && p.ref != v2 && (g2 || (g2 = [])).push(v2, u3.__c || d2, u3), null != d2) {
        if (null == m2 && (m2 = d2), null != u3.l) {
          d2 = u3.l, u3.l = null;
        } else if (r2 == p || d2 != c2 || null == d2.parentNode) {
          n:
            if (null == c2 || c2.parentNode !== n2) {
              n2.appendChild(d2);
            } else {
              for (y2 = c2, v2 = 0; (y2 = y2.nextSibling) && v2 < _2; v2 += 2) {
                if (y2 == d2) {
                  break n;
                }
              }
              n2.insertBefore(d2, c2);
            }
          "option" == l.type && (n2.value = "");
        }
        c2 = d2.nextSibling, "function" == typeof l.type && (l.l = d2);
      }
    }
    return h2++, u3;
  }), l.__e = m2, null != r2 && "function" != typeof l.type) {
    for (h2 = r2.length; h2--; ) {
      null != r2[h2] && a(r2[h2]);
    }
  }
  for (h2 = _2; h2--; ) {
    null != k2[h2] && D(k2[h2], k2[h2]);
  }
  if (g2) {
    for (h2 = 0; h2 < g2.length; h2++) {
      A(g2[h2], g2[++h2], g2[++h2]);
    }
  }
}
function x(n2, l, u2) {
  if (null == u2 && (u2 = []), null == n2 || "boolean" == typeof n2) {
    l && u2.push(l(null));
  } else if (Array.isArray(n2)) {
    for (var t2 = 0; t2 < n2.length; t2++) {
      x(n2[t2], l, u2);
    }
  } else {
    u2.push(l ? l(y(n2)) : n2);
  }
  return u2;
}
function C(n2, l, u2, t2, i2) {
  var r2;
  for (r2 in u2) {
    r2 in l || N(n2, r2, null, u2[r2], t2);
  }
  for (r2 in l) {
    i2 && "function" != typeof l[r2] || "value" === r2 || "checked" === r2 || u2[r2] === l[r2] || N(n2, r2, l[r2], u2[r2], t2);
  }
}
function P(n2, l, u2) {
  "-" === l[0] ? n2.setProperty(l, u2) : n2[l] = "number" == typeof u2 && false === c.test(l) ? u2 + "px" : null == u2 ? "" : u2;
}
function N(n2, l, u2, t2, i2) {
  var r2, o2, f2, e2, c2;
  if ("key" === (l = i2 ? "className" === l ? "class" : l : "class" === l ? "className" : l) || "children" === l)
    ;
  else if ("style" === l) {
    if (r2 = n2.style, "string" == typeof u2) {
      r2.cssText = u2;
    } else {
      if ("string" == typeof t2 && (r2.cssText = "", t2 = null), t2) {
        for (o2 in t2) {
          u2 && o2 in u2 || P(r2, o2, "");
        }
      }
      if (u2) {
        for (f2 in u2) {
          t2 && u2[f2] === t2[f2] || P(r2, f2, u2[f2]);
        }
      }
    }
  } else {
    "o" === l[0] && "n" === l[1] ? (e2 = l !== (l = l.replace(/Capture$/, "")), c2 = l.toLowerCase(), l = (c2 in n2 ? c2 : l).slice(2), u2 ? (t2 || n2.addEventListener(l, T, e2), (n2.t || (n2.t = {}))[l] = u2) : n2.removeEventListener(l, T, e2)) : "list" !== l && "tagName" !== l && "form" !== l && !i2 && l in n2 ? n2[l] = null == u2 ? "" : u2 : "function" != typeof u2 && "dangerouslySetInnerHTML" !== l && (l !== (l = l.replace(/^xlink:?/, "")) ? null == u2 || false === u2 ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase(), u2) : null == u2 || false === u2 ? n2.removeAttribute(l) : n2.setAttribute(l, u2));
  }
}
function T(l) {
  return this.t[l.type](n.event ? n.event(l) : l);
}
function $(l, u2, t2, i2, r2, o2, f2, e2, c2, a2) {
  var h2, v2, p, y2, w2, g2, k2, _2, C2, P2, N2 = u2.type;
  if (void 0 !== u2.constructor) {
    return null;
  }
  (h2 = n.__b) && h2(u2);
  try {
    n:
      if ("function" == typeof N2) {
        if (_2 = u2.props, C2 = (h2 = N2.contextType) && i2[h2.__c], P2 = h2 ? C2 ? C2.props.value : h2.__p : i2, t2.__c ? k2 = (v2 = u2.__c = t2.__c).__p = v2.__E : ("prototype" in N2 && N2.prototype.render ? u2.__c = v2 = new N2(_2, P2) : (u2.__c = v2 = new m(_2, P2), v2.constructor = N2, v2.render = H), C2 && C2.sub(v2), v2.props = _2, v2.state || (v2.state = {}), v2.context = P2, v2.__n = i2, p = v2.__d = true, v2.__h = []), null == v2.__s && (v2.__s = v2.state), null != N2.getDerivedStateFromProps && s(v2.__s == v2.state ? v2.__s = s({}, v2.__s) : v2.__s, N2.getDerivedStateFromProps(_2, v2.__s)), p) {
          null == N2.getDerivedStateFromProps && null != v2.componentWillMount && v2.componentWillMount(), null != v2.componentDidMount && f2.push(v2);
        } else {
          if (null == N2.getDerivedStateFromProps && null == e2 && null != v2.componentWillReceiveProps && v2.componentWillReceiveProps(_2, P2), !e2 && null != v2.shouldComponentUpdate && false === v2.shouldComponentUpdate(_2, v2.__s, P2)) {
            for (v2.props = _2, v2.state = v2.__s, v2.__d = false, v2.__v = u2, u2.__e = null != c2 ? c2 !== t2.__e ? c2 : t2.__e : null, u2.__k = t2.__k, h2 = 0; h2 < u2.__k.length; h2++) {
              u2.__k[h2] && (u2.__k[h2].__p = u2);
            }
            break n;
          }
          null != v2.componentWillUpdate && v2.componentWillUpdate(_2, v2.__s, P2);
        }
        for (y2 = v2.props, w2 = v2.state, v2.context = P2, v2.props = _2, v2.state = v2.__s, (h2 = n.__r) && h2(u2), v2.__d = false, v2.__v = u2, v2.__P = l, h2 = v2.render(v2.props, v2.state, v2.context), u2.__k = x(null != h2 && h2.type == d && null == h2.key ? h2.props.children : h2), null != v2.getChildContext && (i2 = s(s({}, i2), v2.getChildContext())), p || null == v2.getSnapshotBeforeUpdate || (g2 = v2.getSnapshotBeforeUpdate(y2, w2)), b(l, u2, t2, i2, r2, o2, f2, c2, a2), v2.base = u2.__e; h2 = v2.__h.pop(); ) {
          v2.__s && (v2.state = v2.__s), h2.call(v2);
        }
        p || null == y2 || null == v2.componentDidUpdate || v2.componentDidUpdate(y2, w2, g2), k2 && (v2.__E = v2.__p = null);
      } else {
        u2.__e = z(t2.__e, u2, t2, i2, r2, o2, f2, a2);
      }
    (h2 = n.diffed) && h2(u2);
  } catch (l2) {
    n.__e(l2, u2, t2);
  }
  return u2.__e;
}
function j(l, u2) {
  for (var t2; t2 = l.pop(); ) {
    try {
      t2.componentDidMount();
    } catch (l2) {
      n.__e(l2, t2.__v);
    }
  }
  n.__c && n.__c(u2);
}
function z(n2, l, u2, t2, i2, r2, o2, c2) {
  var s2, a2, h2, v2, p = u2.props, d2 = l.props;
  if (i2 = "svg" === l.type || i2, null == n2 && null != r2) {
    for (s2 = 0; s2 < r2.length; s2++) {
      if (null != (a2 = r2[s2]) && (null === l.type ? 3 === a2.nodeType : a2.localName === l.type)) {
        n2 = a2, r2[s2] = null;
        break;
      }
    }
  }
  if (null == n2) {
    if (null === l.type) {
      return document.createTextNode(d2);
    }
    n2 = i2 ? document.createElementNS("http://www.w3.org/2000/svg", l.type) : document.createElement(l.type), r2 = null;
  }
  return null === l.type ? p !== d2 && (null != r2 && (r2[r2.indexOf(n2)] = null), n2.data = d2) : l !== u2 && (null != r2 && (r2 = e.slice.call(n2.childNodes)), h2 = (p = u2.props || f).dangerouslySetInnerHTML, v2 = d2.dangerouslySetInnerHTML, c2 || (v2 || h2) && (v2 && h2 && v2.__html == h2.__html || (n2.innerHTML = v2 && v2.__html || "")), C(n2, d2, p, i2, c2), l.__k = l.props.children, v2 || b(n2, l, u2, t2, "foreignObject" !== l.type && i2, r2, o2, f, c2), c2 || ("value" in d2 && void 0 !== d2.value && d2.value !== n2.value && (n2.value = null == d2.value ? "" : d2.value), "checked" in d2 && void 0 !== d2.checked && d2.checked !== n2.checked && (n2.checked = d2.checked))), n2;
}
function A(l, u2, t2) {
  try {
    "function" == typeof l ? l(u2) : l.current = u2;
  } catch (l2) {
    n.__e(l2, t2);
  }
}
function D(l, u2, t2) {
  var i2, r2, o2;
  if (n.unmount && n.unmount(l), (i2 = l.ref) && A(i2, null, u2), t2 || "function" == typeof l.type || (t2 = null != (r2 = l.__e)), l.__e = l.l = null, null != (i2 = l.__c)) {
    if (i2.componentWillUnmount) {
      try {
        i2.componentWillUnmount();
      } catch (l2) {
        n.__e(l2, u2);
      }
    }
    i2.base = i2.__P = null;
  }
  if (i2 = l.__k) {
    for (o2 = 0; o2 < i2.length; o2++) {
      i2[o2] && D(i2[o2], u2, t2);
    }
  }
  null != r2 && a(r2);
}
function H(n2, l, u2) {
  return this.constructor(n2, u2);
}
function I(l, u2, t2) {
  var i2, o2, c2;
  n.__p && n.__p(l, u2), o2 = (i2 = t2 === r) ? null : t2 && t2.__k || u2.__k, l = h(d, null, [l]), c2 = [], $(u2, i2 ? u2.__k = l : (t2 || u2).__k = l, o2 || f, f, void 0 !== u2.ownerSVGElement, t2 && !i2 ? [t2] : o2 ? null : e.slice.call(u2.childNodes), c2, false, t2 || f, i2), j(c2, l);
}
n = {}, m.prototype.setState = function(n2, l) {
  var u2 = this.__s !== this.state && this.__s || (this.__s = s({}, this.state));
  ("function" != typeof n2 || (n2 = n2(u2, this.props))) && s(u2, n2), null != n2 && this.__v && (this.u = false, l && this.__h.push(l), k(this));
}, m.prototype.forceUpdate = function(n2) {
  this.__v && (n2 && this.__h.push(n2), this.u = true, k(this));
}, m.prototype.render = d, u = [], t = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, i = n.debounceRendering, n.__e = function(n2, l, u2) {
  for (var t2; l = l.__p; ) {
    if ((t2 = l.__c) && !t2.__p) {
      try {
        if (t2.constructor && null != t2.constructor.getDerivedStateFromError) {
          t2.setState(t2.constructor.getDerivedStateFromError(n2));
        } else {
          if (null == t2.componentDidCatch) {
            continue;
          }
          t2.componentDidCatch(n2);
        }
        return k(t2.__E = t2);
      } catch (l2) {
        n2 = l2;
      }
    }
  }
  throw n2;
}, r = f, o = 0;
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) {
      descriptor.writable = true;
    }
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) {
    _defineProperties(Constructor.prototype, protoProps);
  }
  if (staticProps) {
    _defineProperties(Constructor, staticProps);
  }
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    var arguments$1 = arguments;
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments$1[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
var PERMISSIVE_MATCH_3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
var PERMISSIVE_MATCH_4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
var REGEX_FUNCTIONAL_RGB = new RegExp("rgb" + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_RGBA = new RegExp("rgba" + PERMISSIVE_MATCH_4);
var REGEX_FUNCTIONAL_HSL = new RegExp("hsl" + PERMISSIVE_MATCH_3);
var REGEX_FUNCTIONAL_HSLA = new RegExp("hsla" + PERMISSIVE_MATCH_4);
var HEX_START = "^(?:#?|0x?)";
var HEX_INT_SINGLE = "([0-9a-fA-F]{1})";
var HEX_INT_DOUBLE = "([0-9a-fA-F]{2})";
var REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + "$");
var REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + "$");
var REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + "$");
var REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + "$");
var KELVIN_MIN = 2e3;
var KELVIN_MAX = 4e4;
var log = Math.log;
var round = Math.round;
var floor = Math.floor;
function clamp(num, min, max) {
  return Math.min(Math.max(num, min), max);
}
function parseUnit(str, max) {
  var isPercentage = str.indexOf("%") > -1;
  var num = parseFloat(str);
  return isPercentage ? max / 100 * num : num;
}
function parseHexInt(str) {
  return parseInt(str, 16);
}
function intToHex(_int) {
  return _int.toString(16).padStart(2, "0");
}
var IroColor = function() {
  function IroColor2(value, onChange) {
    this.$ = {
      h: 0,
      s: 0,
      v: 0,
      a: 1
    };
    if (value) {
      this.set(value);
    }
    this.onChange = onChange;
    this.initialValue = _extends({}, this.$);
  }
  var _proto = IroColor2.prototype;
  _proto.set = function set(value) {
    if (typeof value === "string") {
      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {
        this.hexString = value;
      } else if (/^rgba?/.test(value)) {
        this.rgbString = value;
      } else if (/^hsla?/.test(value)) {
        this.hslString = value;
      }
    } else if (typeof value === "object") {
      if (value instanceof IroColor2) {
        this.hsva = value.hsva;
      } else if ("r" in value && "g" in value && "b" in value) {
        this.rgb = value;
      } else if ("h" in value && "s" in value && "v" in value) {
        this.hsv = value;
      } else if ("h" in value && "s" in value && "l" in value) {
        this.hsl = value;
      } else if ("kelvin" in value) {
        this.kelvin = value.kelvin;
      }
    } else {
      throw new Error("Invalid color value");
    }
  };
  _proto.setChannel = function setChannel(format, channel, value) {
    var _extends2;
    this[format] = _extends({}, this[format], (_extends2 = {}, _extends2[channel] = value, _extends2));
  };
  _proto.reset = function reset() {
    this.hsva = this.initialValue;
  };
  _proto.clone = function clone() {
    return new IroColor2(this);
  };
  _proto.unbind = function unbind() {
    this.onChange = void 0;
  };
  IroColor2.hsvToRgb = function hsvToRgb(hsv) {
    var h2 = hsv.h / 60;
    var s2 = hsv.s / 100;
    var v2 = hsv.v / 100;
    var i2 = floor(h2);
    var f2 = h2 - i2;
    var p = v2 * (1 - s2);
    var q = v2 * (1 - f2 * s2);
    var t2 = v2 * (1 - (1 - f2) * s2);
    var mod3 = i2 % 6;
    var r2 = [v2, q, p, p, t2, v2][mod3];
    var g2 = [t2, v2, v2, q, p, p][mod3];
    var b2 = [p, p, t2, v2, v2, q][mod3];
    return {
      r: clamp(r2 * 255, 0, 255),
      g: clamp(g2 * 255, 0, 255),
      b: clamp(b2 * 255, 0, 255)
    };
  };
  IroColor2.rgbToHsv = function rgbToHsv(rgb) {
    var r2 = rgb.r / 255;
    var g2 = rgb.g / 255;
    var b2 = rgb.b / 255;
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var delta = max - min;
    var hue = 0;
    var value = max;
    var saturation = max === 0 ? 0 : delta / max;
    switch (max) {
      case min:
        hue = 0;
        break;
      case r2:
        hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        hue = (b2 - r2) / delta + 2;
        break;
      case b2:
        hue = (r2 - g2) / delta + 4;
        break;
    }
    return {
      h: hue * 60 % 360,
      s: clamp(saturation * 100, 0, 100),
      v: clamp(value * 100, 0, 100)
    };
  };
  IroColor2.hsvToHsl = function hsvToHsl(hsv) {
    var s2 = hsv.s / 100;
    var v2 = hsv.v / 100;
    var l = (2 - s2) * v2;
    var divisor = l <= 1 ? l : 2 - l;
    var saturation = divisor < 1e-9 ? 0 : s2 * v2 / divisor;
    return {
      h: hsv.h,
      s: clamp(saturation * 100, 0, 100),
      l: clamp(l * 50, 0, 100)
    };
  };
  IroColor2.hslToHsv = function hslToHsv(hsl) {
    var l = hsl.l * 2;
    var s2 = hsl.s * (l <= 100 ? l : 200 - l) / 100;
    var saturation = l + s2 < 1e-9 ? 0 : 2 * s2 / (l + s2);
    return {
      h: hsl.h,
      s: clamp(saturation * 100, 0, 100),
      v: clamp((l + s2) / 2, 0, 100)
    };
  };
  IroColor2.kelvinToRgb = function kelvinToRgb(kelvin) {
    var temp = kelvin / 100;
    var r2, g2, b2;
    if (temp < 66) {
      r2 = 255;
      g2 = -155.25485562709179 - 0.44596950469579133 * (g2 = temp - 2) + 104.49216199393888 * log(g2);
      b2 = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b2 = temp - 10) + 115.67994401066147 * log(b2);
    } else {
      r2 = 351.97690566805693 + 0.114206453784165 * (r2 = temp - 55) - 40.25366309332127 * log(r2);
      g2 = 325.4494125711974 + 0.07943456536662342 * (g2 = temp - 50) - 28.0852963507957 * log(g2);
      b2 = 255;
    }
    return {
      r: clamp(floor(r2), 0, 255),
      g: clamp(floor(g2), 0, 255),
      b: clamp(floor(b2), 0, 255)
    };
  };
  IroColor2.rgbToKelvin = function rgbToKelvin(rgb) {
    var r2 = rgb.r, b2 = rgb.b;
    var eps = 0.4;
    var minTemp = KELVIN_MIN;
    var maxTemp = KELVIN_MAX;
    var temp;
    while (maxTemp - minTemp > eps) {
      temp = (maxTemp + minTemp) * 0.5;
      var _rgb = IroColor2.kelvinToRgb(temp);
      if (_rgb.b / _rgb.r >= b2 / r2) {
        maxTemp = temp;
      } else {
        minTemp = temp;
      }
    }
    return temp;
  };
  _createClass(IroColor2, [{
    key: "hsv",
    get: function get() {
      var value = this.$;
      return {
        h: value.h,
        s: value.s,
        v: value.v
      };
    },
    set: function set(newValue) {
      var oldValue = this.$;
      newValue = _extends({}, oldValue, newValue);
      if (this.onChange) {
        var changes = {
          h: false,
          v: false,
          s: false,
          a: false
        };
        for (var key in oldValue) {
          changes[key] = newValue[key] != oldValue[key];
        }
        this.$ = newValue;
        if (changes.h || changes.s || changes.v || changes.a) {
          this.onChange(this, changes);
        }
      } else {
        this.$ = newValue;
      }
    }
  }, {
    key: "hsva",
    get: function get() {
      return _extends({}, this.$);
    },
    set: function set(value) {
      this.hsv = value;
    }
  }, {
    key: "hue",
    get: function get() {
      return this.$.h;
    },
    set: function set(value) {
      this.hsv = {
        h: value
      };
    }
  }, {
    key: "saturation",
    get: function get() {
      return this.$.s;
    },
    set: function set(value) {
      this.hsv = {
        s: value
      };
    }
  }, {
    key: "value",
    get: function get() {
      return this.$.v;
    },
    set: function set(value) {
      this.hsv = {
        v: value
      };
    }
  }, {
    key: "alpha",
    get: function get() {
      return this.$.a;
    },
    set: function set(value) {
      this.hsv = _extends({}, this.hsv, {
        a: value
      });
    }
  }, {
    key: "kelvin",
    get: function get() {
      return IroColor2.rgbToKelvin(this.rgb);
    },
    set: function set(value) {
      this.rgb = IroColor2.kelvinToRgb(value);
    }
  }, {
    key: "red",
    get: function get() {
      var rgb = this.rgb;
      return rgb.r;
    },
    set: function set(value) {
      this.rgb = _extends({}, this.rgb, {
        r: value
      });
    }
  }, {
    key: "green",
    get: function get() {
      var rgb = this.rgb;
      return rgb.g;
    },
    set: function set(value) {
      this.rgb = _extends({}, this.rgb, {
        g: value
      });
    }
  }, {
    key: "blue",
    get: function get() {
      var rgb = this.rgb;
      return rgb.b;
    },
    set: function set(value) {
      this.rgb = _extends({}, this.rgb, {
        b: value
      });
    }
  }, {
    key: "rgb",
    get: function get() {
      var _IroColor$hsvToRgb = IroColor2.hsvToRgb(this.$), r2 = _IroColor$hsvToRgb.r, g2 = _IroColor$hsvToRgb.g, b2 = _IroColor$hsvToRgb.b;
      return {
        r: round(r2),
        g: round(g2),
        b: round(b2)
      };
    },
    set: function set(value) {
      this.hsv = _extends({}, IroColor2.rgbToHsv(value), {
        a: value.a === void 0 ? 1 : value.a
      });
    }
  }, {
    key: "rgba",
    get: function get() {
      return _extends({}, this.rgb, {
        a: this.alpha
      });
    },
    set: function set(value) {
      this.rgb = value;
    }
  }, {
    key: "hsl",
    get: function get() {
      var _IroColor$hsvToHsl = IroColor2.hsvToHsl(this.$), h2 = _IroColor$hsvToHsl.h, s2 = _IroColor$hsvToHsl.s, l = _IroColor$hsvToHsl.l;
      return {
        h: round(h2),
        s: round(s2),
        l: round(l)
      };
    },
    set: function set(value) {
      this.hsv = _extends({}, IroColor2.hslToHsv(value), {
        a: value.a === void 0 ? 1 : value.a
      });
    }
  }, {
    key: "hsla",
    get: function get() {
      return _extends({}, this.hsl, {
        a: this.alpha
      });
    },
    set: function set(value) {
      this.hsl = value;
    }
  }, {
    key: "rgbString",
    get: function get() {
      var rgb = this.rgb;
      return "rgb(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ")";
    },
    set: function set(value) {
      var match;
      var r2, g2, b2, a2 = 1;
      if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {
        r2 = parseUnit(match[1], 255);
        g2 = parseUnit(match[2], 255);
        b2 = parseUnit(match[3], 255);
      } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {
        r2 = parseUnit(match[1], 255);
        g2 = parseUnit(match[2], 255);
        b2 = parseUnit(match[3], 255);
        a2 = parseUnit(match[4], 1);
      }
      if (match) {
        this.rgb = {
          r: r2,
          g: g2,
          b: b2,
          a: a2
        };
      } else {
        throw new Error("Invalid rgb string");
      }
    }
  }, {
    key: "rgbaString",
    get: function get() {
      var rgba = this.rgba;
      return "rgba(" + rgba.r + ", " + rgba.g + ", " + rgba.b + ", " + rgba.a + ")";
    },
    set: function set(value) {
      this.rgbString = value;
    }
  }, {
    key: "hexString",
    get: function get() {
      var rgb = this.rgb;
      return "#" + intToHex(rgb.r) + intToHex(rgb.g) + intToHex(rgb.b);
    },
    set: function set(value) {
      var match;
      var r2, g2, b2, a2 = 255;
      if (match = REGEX_HEX_3.exec(value)) {
        r2 = parseHexInt(match[1]) * 17;
        g2 = parseHexInt(match[2]) * 17;
        b2 = parseHexInt(match[3]) * 17;
      } else if (match = REGEX_HEX_4.exec(value)) {
        r2 = parseHexInt(match[1]) * 17;
        g2 = parseHexInt(match[2]) * 17;
        b2 = parseHexInt(match[3]) * 17;
        a2 = parseHexInt(match[4]) * 17;
      } else if (match = REGEX_HEX_6.exec(value)) {
        r2 = parseHexInt(match[1]);
        g2 = parseHexInt(match[2]);
        b2 = parseHexInt(match[3]);
      } else if (match = REGEX_HEX_8.exec(value)) {
        r2 = parseHexInt(match[1]);
        g2 = parseHexInt(match[2]);
        b2 = parseHexInt(match[3]);
        a2 = parseHexInt(match[4]);
      }
      if (match) {
        this.rgb = {
          r: r2,
          g: g2,
          b: b2,
          a: a2 / 255
        };
      } else {
        throw new Error("Invalid hex string");
      }
    }
  }, {
    key: "hex8String",
    get: function get() {
      var rgba = this.rgba;
      return "#" + intToHex(rgba.r) + intToHex(rgba.g) + intToHex(rgba.b) + intToHex(floor(rgba.a * 255));
    },
    set: function set(value) {
      this.hexString = value;
    }
  }, {
    key: "hslString",
    get: function get() {
      var hsl = this.hsl;
      return "hsl(" + hsl.h + ", " + hsl.s + "%, " + hsl.l + "%)";
    },
    set: function set(value) {
      var match;
      var h2, s2, l, a2 = 1;
      if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {
        h2 = parseUnit(match[1], 360);
        s2 = parseUnit(match[2], 100);
        l = parseUnit(match[3], 100);
      } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {
        h2 = parseUnit(match[1], 360);
        s2 = parseUnit(match[2], 100);
        l = parseUnit(match[3], 100);
        a2 = parseUnit(match[4], 1);
      }
      if (match) {
        this.hsl = {
          h: h2,
          s: s2,
          l,
          a: a2
        };
      } else {
        throw new Error("Invalid hsl string");
      }
    }
  }, {
    key: "hslaString",
    get: function get() {
      var hsla = this.hsla;
      return "hsla(" + hsla.h + ", " + hsla.s + "%, " + hsla.l + "%, " + hsla.a + ")";
    },
    set: function set(value) {
      this.hslString = value;
    }
  }]);
  return IroColor2;
}();
var sliderDefaultOptions = {
  sliderShape: "bar",
  sliderType: "value",
  minTemperature: 2200,
  maxTemperature: 11e3
};
function getSliderDimensions(props) {
  var _sliderSize;
  var width = props.width, sliderSize = props.sliderSize, borderWidth = props.borderWidth, handleRadius = props.handleRadius, padding = props.padding, sliderShape = props.sliderShape;
  var ishorizontal = props.layoutDirection === "horizontal";
  sliderSize = (_sliderSize = sliderSize) != null ? _sliderSize : padding * 2 + handleRadius * 2;
  if (sliderShape === "circle") {
    return {
      handleStart: props.padding + props.handleRadius,
      handleRange: width - padding * 2 - handleRadius * 2,
      width,
      height: width,
      cx: width / 2,
      cy: width / 2,
      radius: width / 2 - borderWidth / 2
    };
  } else {
    return {
      handleStart: sliderSize / 2,
      handleRange: width - sliderSize,
      radius: sliderSize / 2,
      x: 0,
      y: 0,
      width: ishorizontal ? sliderSize : width,
      height: ishorizontal ? width : sliderSize
    };
  }
}
function getCurrentSliderValue(props, color) {
  var hsva = color.hsva;
  var rgb = color.rgb;
  switch (props.sliderType) {
    case "red":
      return rgb.r / 2.55;
    case "green":
      return rgb.g / 2.55;
    case "blue":
      return rgb.b / 2.55;
    case "alpha":
      return hsva.a * 100;
    case "kelvin":
      var minTemperature = props.minTemperature, maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      var percent = (color.kelvin - minTemperature) / temperatureRange * 100;
      return Math.max(0, Math.min(percent, 100));
    case "hue":
      return hsva.h /= 3.6;
    case "saturation":
      return hsva.s;
    case "value":
    default:
      return hsva.v;
  }
}
function getSliderValueFromInput(props, x2, y2) {
  var _getSliderDimensions = getSliderDimensions(props), handleRange = _getSliderDimensions.handleRange, handleStart = _getSliderDimensions.handleStart;
  var handlePos;
  if (props.layoutDirection === "horizontal") {
    handlePos = -1 * y2 + handleRange + handleStart;
  } else {
    handlePos = x2 - handleStart;
  }
  handlePos = Math.max(Math.min(handlePos, handleRange), 0);
  var percent = Math.round(100 / handleRange * handlePos);
  switch (props.sliderType) {
    case "kelvin":
      var minTemperature = props.minTemperature, maxTemperature = props.maxTemperature;
      var temperatureRange = maxTemperature - minTemperature;
      return minTemperature + temperatureRange * (percent / 100);
    case "alpha":
      return percent / 100;
    case "hue":
      return percent * 3.6;
    case "red":
    case "blue":
    case "green":
      return percent * 2.55;
    default:
      return percent;
  }
}
function getSliderHandlePosition(props, color) {
  var _getSliderDimensions2 = getSliderDimensions(props), width = _getSliderDimensions2.width, height = _getSliderDimensions2.height, handleRange = _getSliderDimensions2.handleRange, handleStart = _getSliderDimensions2.handleStart;
  var ishorizontal = props.layoutDirection === "horizontal";
  var sliderValue = getCurrentSliderValue(props, color);
  var midPoint = ishorizontal ? width / 2 : height / 2;
  var handlePos = handleStart + sliderValue / 100 * handleRange;
  if (ishorizontal) {
    handlePos = -1 * handlePos + handleRange + handleStart * 2;
  }
  return {
    x: ishorizontal ? midPoint : handlePos,
    y: ishorizontal ? handlePos : midPoint
  };
}
function getSliderGradient(props, color) {
  var hsv = color.hsv;
  var rgb = color.rgb;
  switch (props.sliderType) {
    case "red":
      return [[0, "rgb(0," + rgb.g + "," + rgb.b + ")"], [100, "rgb(255," + rgb.g + "," + rgb.b + ")"]];
    case "green":
      return [[0, "rgb(" + rgb.r + ",0," + rgb.b + ")"], [100, "rgb(" + rgb.r + ",255," + rgb.b + ")"]];
    case "blue":
      return [[0, "rgb(" + rgb.r + "," + rgb.g + ",0)"], [100, "rgb(" + rgb.r + "," + rgb.g + ",255)"]];
    case "alpha":
      return [[0, "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ",0)"], [100, "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")"]];
    case "kelvin":
      var stops = [];
      var min = props.minTemperature;
      var max = props.maxTemperature;
      var numStops = 8;
      var range = max - min;
      for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {
        var _IroColor$kelvinToRgb = IroColor.kelvinToRgb(kelvin), r2 = _IroColor$kelvinToRgb.r, g2 = _IroColor$kelvinToRgb.g, b2 = _IroColor$kelvinToRgb.b;
        stops.push([100 / numStops * stop, "rgb(" + r2 + "," + g2 + "," + b2 + ")"]);
      }
      return stops;
    case "hue":
      return [[0, "#f00"], [16.666, "#ff0"], [33.333, "#0f0"], [50, "#0ff"], [66.666, "#00f"], [83.333, "#f0f"], [100, "#f00"]];
    case "saturation":
      var noSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 0,
        v: hsv.v
      });
      var fullSat = IroColor.hsvToHsl({
        h: hsv.h,
        s: 100,
        v: hsv.v
      });
      return [[0, "hsl(" + noSat.h + "," + noSat.s + "%," + noSat.l + "%)"], [100, "hsl(" + fullSat.h + "," + fullSat.s + "%," + fullSat.l + "%)"]];
    case "value":
    default:
      var hsl = IroColor.hsvToHsl({
        h: hsv.h,
        s: hsv.s,
        v: 100
      });
      return [[0, "#000"], [100, "hsl(" + hsl.h + "," + hsl.s + "%," + hsl.l + "%)"]];
  }
}
var TAU = Math.PI * 2;
var mod = function mod2(a2, n2) {
  return (a2 % n2 + n2) % n2;
};
var dist = function dist2(x2, y2) {
  return Math.sqrt(x2 * x2 + y2 * y2);
};
function getHandleRange(props) {
  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;
}
function isInputInsideWheel(props, x2, y2) {
  var _getWheelDimensions = getWheelDimensions(props), cx = _getWheelDimensions.cx, cy = _getWheelDimensions.cy;
  var r2 = props.width / 2;
  return dist(cx - x2, cy - y2) < r2;
}
function getWheelDimensions(props) {
  var r2 = props.width / 2;
  return {
    width: props.width,
    radius: r2 - props.borderWidth,
    cx: r2,
    cy: r2
  };
}
function translateWheelAngle(props, angle, invert) {
  var wheelAngle = props.wheelAngle;
  var wheelDirection = props.wheelDirection;
  if (invert && wheelDirection === "clockwise") {
    angle = wheelAngle + angle;
  } else if (wheelDirection === "clockwise") {
    angle = 360 - wheelAngle + angle;
  } else if (invert && wheelDirection === "anticlockwise") {
    angle = wheelAngle + 180 - angle;
  } else if (wheelDirection === "anticlockwise") {
    angle = wheelAngle - angle;
  }
  return mod(angle, 360);
}
function getWheelHandlePosition(props, color) {
  var hsv = color.hsv;
  var _getWheelDimensions2 = getWheelDimensions(props), cx = _getWheelDimensions2.cx, cy = _getWheelDimensions2.cy;
  var handleRange = getHandleRange(props);
  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);
  var handleDist = hsv.s / 100 * handleRange;
  var direction = props.wheelDirection === "clockwise" ? -1 : 1;
  return {
    x: cx + handleDist * Math.cos(handleAngle) * direction,
    y: cy + handleDist * Math.sin(handleAngle) * direction
  };
}
function getWheelValueFromInput(props, x2, y2) {
  var _getWheelDimensions3 = getWheelDimensions(props), cx = _getWheelDimensions3.cx, cy = _getWheelDimensions3.cy;
  var handleRange = getHandleRange(props);
  x2 = cx - x2;
  y2 = cy - y2;
  var hue = translateWheelAngle(props, Math.atan2(-y2, -x2) * (360 / TAU));
  var handleDist = Math.min(dist(x2, y2), handleRange);
  return {
    h: Math.round(hue),
    s: Math.round(100 / handleRange * handleDist)
  };
}
function getBoxDimensions(props) {
  var width = props.width, boxHeight = props.boxHeight, padding = props.padding, handleRadius = props.handleRadius;
  return {
    width,
    height: boxHeight != null ? boxHeight : width,
    radius: padding + handleRadius
  };
}
function getBoxValueFromInput(props, x2, y2) {
  var _getBoxDimensions = getBoxDimensions(props), width = _getBoxDimensions.width, height = _getBoxDimensions.height, radius = _getBoxDimensions.radius;
  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  var percentX = (x2 - handleStart) / handleRangeX * 100;
  var percentY = (y2 - handleStart) / handleRangeY * 100;
  return {
    s: Math.max(0, Math.min(percentX, 100)),
    v: Math.max(0, Math.min(100 - percentY, 100))
  };
}
function getBoxHandlePosition(props, color) {
  var _getBoxDimensions2 = getBoxDimensions(props), width = _getBoxDimensions2.width, height = _getBoxDimensions2.height, radius = _getBoxDimensions2.radius;
  var hsv = color.hsv;
  var handleStart = radius;
  var handleRangeX = width - radius * 2;
  var handleRangeY = height - radius * 2;
  return {
    x: handleStart + hsv.s / 100 * handleRangeX,
    y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)
  };
}
function getBoxGradients(props, color) {
  var hue = color.hue;
  return [
    // saturation gradient
    [[0, "#fff"], [100, "hsl(" + hue + ",100%,50%)"]],
    // lightness gradient
    [[0, "rgba(0,0,0,0)"], [100, "#000"]]
  ];
}
var BASE_ELEMENTS;
function resolveSvgUrl(url) {
  if (!BASE_ELEMENTS) {
    BASE_ELEMENTS = document.getElementsByTagName("base");
  }
  var ua = window.navigator.userAgent;
  var isSafari = /^((?!chrome|android).)*safari/i.test(ua);
  var isIos = /iPhone|iPod|iPad/i.test(ua);
  var location = window.location;
  return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? location.protocol + "//" + location.host + location.pathname + location.search + url : url;
}
function getHandleAtPoint(props, x2, y2, handlePositions) {
  for (var i2 = 0; i2 < handlePositions.length; i2++) {
    var dX = handlePositions[i2].x - x2;
    var dY = handlePositions[i2].y - y2;
    var dist3 = Math.sqrt(dX * dX + dY * dY);
    if (dist3 < props.handleRadius) {
      return i2;
    }
  }
  return null;
}
function cssBorderStyles(props) {
  return {
    boxSizing: "border-box",
    border: props.borderWidth + "px solid " + props.borderColor
  };
}
function cssGradient(type, direction, stops) {
  return type + "-gradient(" + direction + ", " + stops.map(function(_ref) {
    var o2 = _ref[0], col = _ref[1];
    return col + " " + o2 + "%";
  }).join(",") + ")";
}
function cssValue(value) {
  if (typeof value === "string") {
    return value;
  }
  return value + "px";
}
var iroColorPickerOptionDefaults = {
  width: 300,
  height: 300,
  color: "#fff",
  colors: [],
  padding: 6,
  layoutDirection: "vertical",
  borderColor: "#fff",
  borderWidth: 0,
  handleRadius: 8,
  activeHandleRadius: null,
  handleSvg: null,
  handleProps: {
    x: 0,
    y: 0
  },
  wheelLightness: true,
  wheelAngle: 0,
  wheelDirection: "anticlockwise",
  sliderSize: null,
  sliderMargin: 12,
  boxHeight: null
};
var SECONDARY_EVENTS = [
  "mousemove",
  "touchmove",
  "mouseup",
  "touchend"
  /* TouchEnd */
];
var IroComponentWrapper = function(Component) {
  function IroComponentWrapper2(props) {
    Component.call(this, props);
    this.uid = (Math.random() + 1).toString(36).substring(5);
  }
  if (Component)
    IroComponentWrapper2.__proto__ = Component;
  IroComponentWrapper2.prototype = Object.create(Component && Component.prototype);
  IroComponentWrapper2.prototype.constructor = IroComponentWrapper2;
  IroComponentWrapper2.prototype.render = function render(props) {
    var eventHandler = this.handleEvent.bind(this);
    var rootProps = {
      onMouseDown: eventHandler,
      // https://github.com/jaames/iro.js/issues/126
      // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767
      ontouchstart: eventHandler
    };
    var isHorizontal = props.layoutDirection === "horizontal";
    var margin = props.margin === null ? props.sliderMargin : props.margin;
    var rootStyles = {
      overflow: "visible",
      display: isHorizontal ? "inline-block" : "block"
    };
    if (props.index > 0) {
      rootStyles[isHorizontal ? "marginLeft" : "marginTop"] = margin;
    }
    return h(d, null, props.children(this.uid, rootProps, rootStyles));
  };
  IroComponentWrapper2.prototype.handleEvent = function handleEvent(e2) {
    var this$1 = this;
    var inputHandler = this.props.onInput;
    var bounds = this.base.getBoundingClientRect();
    e2.preventDefault();
    var point = e2.touches ? e2.changedTouches[0] : e2;
    var x2 = point.clientX - bounds.left;
    var y2 = point.clientY - bounds.top;
    switch (e2.type) {
      case "mousedown":
      case "touchstart":
        var result = inputHandler(
          x2,
          y2,
          0
          /* Start */
        );
        if (result !== false) {
          SECONDARY_EVENTS.forEach(function(event) {
            document.addEventListener(event, this$1, { passive: false });
          });
        }
        break;
      case "mousemove":
      case "touchmove":
        inputHandler(
          x2,
          y2,
          1
          /* Move */
        );
        break;
      case "mouseup":
      case "touchend":
        inputHandler(
          x2,
          y2,
          2
          /* End */
        );
        SECONDARY_EVENTS.forEach(function(event) {
          document.removeEventListener(event, this$1, { passive: false });
        });
        break;
    }
  };
  return IroComponentWrapper2;
}(m);
function IroHandle(props) {
  var radius = props.r;
  var url = props.url;
  var cx = radius;
  var cy = radius;
  return h(
    "svg",
    { className: "IroHandle IroHandle--" + props.index + " " + (props.isActive ? "IroHandle--isActive" : ""), style: {
      "-webkit-tap-highlight-color": "rgba(0, 0, 0, 0);",
      transform: "translate(" + cssValue(props.x) + ", " + cssValue(props.y) + ")",
      willChange: "transform",
      top: cssValue(-radius),
      left: cssValue(-radius),
      width: cssValue(radius * 2),
      height: cssValue(radius * 2),
      position: "absolute",
      overflow: "visible"
    } },
    url && h("use", Object.assign({ xlinkHref: resolveSvgUrl(url) }, props.props)),
    !url && h("circle", { cx, cy, r: radius, fill: "none", "stroke-width": 2, stroke: "#000" }),
    !url && h("circle", { cx, cy, r: radius - 2, fill: props.fill, "stroke-width": 2, stroke: "#fff" })
  );
}
IroHandle.defaultProps = {
  fill: "none",
  x: 0,
  y: 0,
  r: 8,
  url: null,
  props: { x: 0, y: 0 }
};
function IroSlider(props) {
  var activeIndex = props.activeIndex;
  var activeColor = activeIndex !== void 0 && activeIndex < props.colors.length ? props.colors[activeIndex] : props.color;
  var ref = getSliderDimensions(props);
  var width = ref.width;
  var height = ref.height;
  var radius = ref.radius;
  var handlePos = getSliderHandlePosition(props, activeColor);
  var gradient = getSliderGradient(props, activeColor);
  function handleInput(x2, y2, type) {
    var value = getSliderValueFromInput(props, x2, y2);
    props.parent.inputActive = true;
    activeColor[props.sliderType] = value;
    props.onInput(type, props.id);
  }
  return h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function(uid, rootProps, rootStyles) {
    return h(
      "div",
      Object.assign({}, rootProps, { className: "IroSlider", style: Object.assign(
        {},
        {
          position: "relative",
          width: cssValue(width),
          height: cssValue(height),
          borderRadius: cssValue(radius),
          // checkered bg to represent alpha
          background: "conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0)",
          backgroundSize: "8px 8px"
        },
        rootStyles
      ) }),
      h("div", { className: "IroSliderGradient", style: Object.assign(
        {},
        {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          borderRadius: cssValue(radius),
          background: cssGradient("linear", props.layoutDirection === "horizontal" ? "to top" : "to right", gradient)
        },
        cssBorderStyles(props)
      ) }),
      h(IroHandle, { isActive: true, index: activeColor.index, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePos.x, y: handlePos.y })
    );
  });
}
IroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);
function IroBox(props) {
  var ref = getBoxDimensions(props);
  var width = ref.width;
  var height = ref.height;
  var radius = ref.radius;
  var colors = props.colors;
  var colorPicker = props.parent;
  var activeIndex = props.activeIndex;
  var activeColor = activeIndex !== void 0 && activeIndex < props.colors.length ? props.colors[activeIndex] : props.color;
  var gradients = getBoxGradients(props, activeColor);
  var handlePositions = colors.map(function(color) {
    return getBoxHandlePosition(props, color);
  });
  function handleInput(x2, y2, inputType) {
    if (inputType === 0) {
      var activeHandle = getHandleAtPoint(props, x2, y2, handlePositions);
      if (activeHandle !== null) {
        colorPicker.setActiveColor(activeHandle);
      } else {
        colorPicker.inputActive = true;
        activeColor.hsv = getBoxValueFromInput(props, x2, y2);
        props.onInput(inputType, props.id);
      }
    } else if (inputType === 1) {
      colorPicker.inputActive = true;
      activeColor.hsv = getBoxValueFromInput(props, x2, y2);
    }
    props.onInput(inputType, props.id);
  }
  return h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function(uid, rootProps, rootStyles) {
    return h(
      "div",
      Object.assign({}, rootProps, { className: "IroBox", style: Object.assign(
        {},
        {
          width: cssValue(width),
          height: cssValue(height),
          position: "relative"
        },
        rootStyles
      ) }),
      h("div", { className: "IroBox", style: Object.assign(
        {},
        {
          width: "100%",
          height: "100%",
          borderRadius: cssValue(radius)
        },
        cssBorderStyles(props),
        { background: cssGradient("linear", "to bottom", gradients[1]) + "," + cssGradient("linear", "to right", gradients[0]) }
      ) }),
      colors.filter(function(color) {
        return color !== activeColor;
      }).map(function(color) {
        return h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y });
      }),
      h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y })
    );
  });
}
var HUE_GRADIENT_CLOCKWISE = "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)";
var HUE_GRADIENT_ANTICLOCKWISE = "conic-gradient(red, magenta, blue, aqua, lime, yellow, red)";
function IroWheel(props) {
  var ref = getWheelDimensions(props);
  var width = ref.width;
  var colors = props.colors;
  var borderWidth = props.borderWidth;
  var colorPicker = props.parent;
  var activeColor = props.color;
  var hsv = activeColor.hsv;
  var handlePositions = colors.map(function(color) {
    return getWheelHandlePosition(props, color);
  });
  var circleStyles = {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    borderRadius: "50%",
    boxSizing: "border-box"
  };
  function handleInput(x2, y2, inputType) {
    if (inputType === 0) {
      if (!isInputInsideWheel(props, x2, y2)) {
        return false;
      }
      var activeHandle = getHandleAtPoint(props, x2, y2, handlePositions);
      if (activeHandle !== null) {
        colorPicker.setActiveColor(activeHandle);
      } else {
        colorPicker.inputActive = true;
        activeColor.hsv = getWheelValueFromInput(props, x2, y2);
        props.onInput(inputType, props.id);
      }
    } else if (inputType === 1) {
      colorPicker.inputActive = true;
      activeColor.hsv = getWheelValueFromInput(props, x2, y2);
    }
    props.onInput(inputType, props.id);
  }
  return h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function(uid, rootProps, rootStyles) {
    return h(
      "div",
      Object.assign({}, rootProps, { className: "IroWheel", style: Object.assign(
        {},
        {
          width: cssValue(width),
          height: cssValue(width),
          position: "relative"
        },
        rootStyles
      ) }),
      h("div", { className: "IroWheelHue", style: Object.assign(
        {},
        circleStyles,
        {
          transform: "rotateZ(" + (props.wheelAngle + 90) + "deg)",
          background: props.wheelDirection === "clockwise" ? HUE_GRADIENT_CLOCKWISE : HUE_GRADIENT_ANTICLOCKWISE
        }
      ) }),
      h("div", { className: "IroWheelSaturation", style: Object.assign(
        {},
        circleStyles,
        { background: "radial-gradient(circle closest-side, #fff, transparent)" }
      ) }),
      props.wheelLightness && h("div", { className: "IroWheelLightness", style: Object.assign(
        {},
        circleStyles,
        {
          background: "#000",
          opacity: 1 - hsv.v / 100
        }
      ) }),
      h("div", { className: "IroWheelBorder", style: Object.assign(
        {},
        circleStyles,
        cssBorderStyles(props)
      ) }),
      colors.filter(function(color) {
        return color !== activeColor;
      }).map(function(color) {
        return h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y });
      }),
      h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y })
    );
  });
}
function createWidget(WidgetComponent) {
  var widgetFactory = function(parent, props) {
    var widget;
    var widgetRoot = document.createElement("div");
    I(h(WidgetComponent, Object.assign(
      {},
      { ref: function(ref) {
        return widget = ref;
      } },
      props
    )), widgetRoot);
    function mountWidget() {
      var container = parent instanceof Element ? parent : document.querySelector(parent);
      container.appendChild(widget.base);
      widget.onMount(container);
    }
    if (document.readyState !== "loading") {
      mountWidget();
    } else {
      document.addEventListener("DOMContentLoaded", mountWidget);
    }
    return widget;
  };
  widgetFactory.prototype = WidgetComponent.prototype;
  Object.assign(widgetFactory, WidgetComponent);
  widgetFactory.__component = WidgetComponent;
  return widgetFactory;
}
var IroColorPicker = function(Component) {
  function IroColorPicker2(props) {
    var this$1 = this;
    Component.call(this, props);
    this.colors = [];
    this.inputActive = false;
    this.events = {};
    this.activeEvents = {};
    this.deferredEvents = {};
    this.id = props.id;
    var colors = props.colors.length > 0 ? props.colors : [props.color];
    colors.forEach(function(colorValue) {
      return this$1.addColor(colorValue);
    });
    this.setActiveColor(0);
    this.state = Object.assign(
      {},
      props,
      {
        color: this.color,
        colors: this.colors,
        layout: props.layout
      }
    );
  }
  if (Component)
    IroColorPicker2.__proto__ = Component;
  IroColorPicker2.prototype = Object.create(Component && Component.prototype);
  IroColorPicker2.prototype.constructor = IroColorPicker2;
  IroColorPicker2.prototype.addColor = function addColor(color, index) {
    if (index === void 0)
      index = this.colors.length;
    var newColor = new IroColor(color, this.onColorChange.bind(this));
    this.colors.splice(index, 0, newColor);
    this.colors.forEach(function(color2, index2) {
      return color2.index = index2;
    });
    if (this.state) {
      this.setState({ colors: this.colors });
    }
    this.deferredEmit("color:init", newColor);
  };
  IroColorPicker2.prototype.removeColor = function removeColor(index) {
    var color = this.colors.splice(index, 1)[0];
    color.unbind();
    this.colors.forEach(function(color2, index2) {
      return color2.index = index2;
    });
    if (this.state) {
      this.setState({ colors: this.colors });
    }
    if (color.index === this.color.index) {
      this.setActiveColor(0);
    }
    this.emit("color:remove", color);
  };
  IroColorPicker2.prototype.setActiveColor = function setActiveColor(index) {
    this.color = this.colors[index];
    if (this.state) {
      this.setState({ color: this.color });
    }
    this.emit("color:setActive", this.color);
  };
  IroColorPicker2.prototype.setColors = function setColors(newColorValues, activeColorIndex) {
    var this$1 = this;
    if (activeColorIndex === void 0)
      activeColorIndex = 0;
    this.colors.forEach(function(color) {
      return color.unbind();
    });
    this.colors = [];
    newColorValues.forEach(function(colorValue) {
      return this$1.addColor(colorValue);
    });
    this.setActiveColor(activeColorIndex);
    this.emit("color:setAll", this.colors);
  };
  IroColorPicker2.prototype.on = function on(eventList, callback) {
    var this$1 = this;
    var events = this.events;
    (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function(eventType) {
      (events[eventType] || (events[eventType] = [])).push(callback);
      if (this$1.deferredEvents[eventType]) {
        this$1.deferredEvents[eventType].forEach(function(args) {
          callback.apply(null, args);
        });
        this$1.deferredEvents[eventType] = [];
      }
    });
  };
  IroColorPicker2.prototype.off = function off(eventList, callback) {
    var this$1 = this;
    (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function(eventType) {
      var callbackList = this$1.events[eventType];
      if (callbackList) {
        callbackList.splice(callbackList.indexOf(callback), 1);
      }
    });
  };
  IroColorPicker2.prototype.emit = function emit(eventType) {
    var this$1 = this;
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    var activeEvents = this.activeEvents;
    var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;
    if (!isEventActive) {
      activeEvents[eventType] = true;
      var callbackList = this.events[eventType] || [];
      callbackList.forEach(function(fn) {
        return fn.apply(this$1, args);
      });
      activeEvents[eventType] = false;
    }
  };
  IroColorPicker2.prototype.deferredEmit = function deferredEmit(eventType) {
    var ref;
    var args = [], len = arguments.length - 1;
    while (len-- > 0)
      args[len] = arguments[len + 1];
    var deferredEvents = this.deferredEvents;
    (ref = this).emit.apply(ref, [eventType].concat(args));
    (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);
  };
  IroColorPicker2.prototype.setOptions = function setOptions(newOptions) {
    this.setState(newOptions);
  };
  IroColorPicker2.prototype.resize = function resize(width) {
    this.setOptions({ width });
  };
  IroColorPicker2.prototype.reset = function reset() {
    this.colors.forEach(function(color) {
      return color.reset();
    });
    this.setState({ colors: this.colors });
  };
  IroColorPicker2.prototype.onMount = function onMount(container) {
    this.el = container;
    this.deferredEmit("mount", this);
  };
  IroColorPicker2.prototype.onColorChange = function onColorChange(color, changes) {
    this.setState({ color: this.color });
    if (this.inputActive) {
      this.inputActive = false;
      this.emit("input:change", color, changes);
    }
    this.emit("color:change", color, changes);
  };
  IroColorPicker2.prototype.emitInputEvent = function emitInputEvent(type, originId) {
    if (type === 0) {
      this.emit("input:start", this.color, originId);
    } else if (type === 1) {
      this.emit("input:move", this.color, originId);
    } else if (type === 2) {
      this.emit("input:end", this.color, originId);
    }
  };
  IroColorPicker2.prototype.render = function render(props, state) {
    var this$1 = this;
    var layout = state.layout;
    if (!Array.isArray(layout)) {
      switch (layout) {
        default:
          layout = [
            { component: IroWheel },
            { component: IroSlider }
          ];
      }
      if (state.transparency) {
        layout.push({
          component: IroSlider,
          options: {
            sliderType: "alpha"
          }
        });
      }
    }
    return h("div", { class: "IroColorPicker", id: state.id, style: {
      display: state.display
    } }, layout.map(function(ref, componentIndex) {
      var UiComponent = ref.component;
      var options = ref.options;
      return h(UiComponent, Object.assign({}, state, options, { ref: void 0, onInput: this$1.emitInputEvent.bind(this$1), parent: this$1, index: componentIndex }));
    }));
  };
  return IroColorPicker2;
}(m);
IroColorPicker.defaultProps = Object.assign(
  {},
  iroColorPickerOptionDefaults,
  {
    colors: [],
    display: "block",
    id: null,
    layout: "default",
    margin: null
  }
);
var IroColorPickerWidget = createWidget(IroColorPicker);
var iro;
(function(iro2) {
  iro2.version = "5.5.2";
  iro2.Color = IroColor;
  iro2.ColorPicker = IroColorPickerWidget;
  var ui;
  (function(ui2) {
    ui2.h = h;
    ui2.ComponentBase = IroComponentWrapper;
    ui2.Handle = IroHandle;
    ui2.Slider = IroSlider;
    ui2.Wheel = IroWheel;
    ui2.Box = IroBox;
  })(ui = iro2.ui || (iro2.ui = {}));
})(iro || (iro = {}));
var iro$1 = iro;
var iro_es_default = iro$1;

// node_modules/blockly-field-color-wheel/src/index.js
var ColorWheelField = class _ColorWheelField extends import_blockly.FieldColour {
  /**
   * Class for the color picker.
   *
   * @param {string} color The starting color for the color.
   *  It's a hex value, #ff00ff.
   * @param {number} width Width of the color picker.
   * @param {ColorPickerProps} options The iro color wheel options.
   */
  constructor(color, width = 150, options = {}) {
    super(color);
    this.color = color;
    this.width = width;
    this.options = options;
  }
  /**
   * Constructs a ColorWheelField from a JSON arg object.
   * @param {!Object} options A JSON object with options.
   * @return {!ColorWheelField} The new field instance.
   * @package
   * @nocollapse
   */
  static fromJson(options) {
    return new _ColorWheelField(
      options["color"],
      options["size"] || 150,
      options["options"] || {}
    );
  }
  /**
   * Over rides colour picker to show the popup.
   */
  showEditor_() {
    const editor = document.createElement("div");
    import_blockly.DropDownDiv.getContentDiv().appendChild(editor);
    editor.classList.add("blockly-color-wheel-container");
    const colorPicker = iro_es_default.ColorPicker(editor, {
      width: this.width,
      // controls the size of the color picker
      color: this.getValue(),
      // starts the color picker at a certain value,
      ...this.options
      // These options will over ride everything
    });
    colorPicker.on("color:change", (color) => {
      this.setValue(color.hexString);
    });
    import_blockly.DropDownDiv.showPositionedByField(this, () => editor.remove());
  }
};
import_blockly.fieldRegistry.register("color_wheel", ColorWheelField);
export {
  ColorWheelField as default
};
/*! Bundled license information:

@jaames/iro/dist/iro.es.js:
  (*!
   * iro.js v5.5.2
   * 2016-2021 James Daniel
   * Licensed under MPL 2.0
   * github.com/jaames/iro.js
   *)

blockly-field-color-wheel/src/index.js:
  (**
   * @license
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=blockly-field-color-wheel.js.map
