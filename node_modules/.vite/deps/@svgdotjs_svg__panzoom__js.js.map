{
  "version": 3,
  "sources": ["../../@svgdotjs/svg.panzoom.js/src/svg.panzoom.js"],
  "sourcesContent": ["import { Svg, on, off, extend, Matrix, Box } from '@svgdotjs/svg.js'\n\nconst normalizeEvent = ev =>\n  ev.touches || [{ clientX: ev.clientX, clientY: ev.clientY }]\n\nextend(Svg, {\n  panZoom (options) {\n    this.off('.panZoom')\n\n    // when called with false, disable panZoom\n    if (options === false) return this\n\n    options = options ?? {}\n    const zoomFactor = options.zoomFactor ?? 2\n    const zoomMin = options.zoomMin ?? Number.MIN_VALUE\n    const zoomMax = options.zoomMax ?? Number.MAX_VALUE\n    const doWheelZoom = options.wheelZoom ?? true\n    const doPinchZoom = options.pinchZoom ?? true\n    const doPanning = options.panning ?? true\n    const panButton = options.panButton ?? 0\n    const oneFingerPan = options.oneFingerPan ?? false\n    const margins = options.margins ?? false\n    const wheelZoomDeltaModeLinePixels = options.wheelZoomDeltaModeLinePixels ?? 17\n    const wheelZoomDeltaModeScreenPixels = options.wheelZoomDeltaModeScreenPixels ?? 53\n\n    let lastP\n    let lastTouches\n    let zoomInProgress = false\n\n    const viewbox = this.viewbox()\n\n    const restrictToMargins = box => {\n      if (!margins) return box\n      const { top, left, bottom, right } = margins\n\n      const { width, height } = this.attr(['width', 'height'])\n      const preserveAspectRatio = this.node.preserveAspectRatio.baseVal\n\n      // The current viewport (exactly what is shown on the screen, what we ultimately want to restrict)\n      // is not always exactly the same as current viewbox. They are different when the viewbox aspectRatio and the svg aspectRatio\n      // are different and preserveAspectRatio is not \"none\". These offsets represent the difference in user coordinates\n      // between the side of the viewbox and the side of the viewport.\n      let viewportLeftOffset = 0\n      let viewportRightOffset = 0\n      let viewportTopOffset = 0\n      let viewportBottomOffset = 0\n\n      // preserveAspectRatio none has no offsets\n      if (preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE) {\n        const svgAspectRatio = width / height\n        const viewboxAspectRatio = viewbox.width / viewbox.height\n        // when aspectRatios are the same, there are no offsets\n        if (viewboxAspectRatio !== svgAspectRatio) {\n          // aspectRatio unknown is like meet because that's the default\n          const isMeet = preserveAspectRatio.meetOrSlice !== preserveAspectRatio.SVG_MEETORSLICE_SLICE\n          const changedAxis = svgAspectRatio > viewboxAspectRatio ? 'width' : 'height'\n          const isWidth = changedAxis === 'width'\n          const changeHorizontal = (isMeet && isWidth) || (!isMeet && !isWidth)\n          const ratio = changeHorizontal\n            ? svgAspectRatio / viewboxAspectRatio\n            : viewboxAspectRatio / svgAspectRatio\n\n          const offset = box[changedAxis] - box[changedAxis] * ratio\n          if (changeHorizontal) {\n            if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX) {\n              viewportLeftOffset = offset / 2\n              viewportRightOffset = -offset / 2\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX) {\n              viewportRightOffset = -offset\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) {\n              viewportLeftOffset = offset\n            }\n          } else {\n            if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID) {\n              viewportTopOffset = offset / 2\n              viewportBottomOffset = -offset / 2\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN) {\n              viewportBottomOffset = -offset\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) {\n              viewportTopOffset = offset\n            }\n          }\n\n        }\n      }\n\n      // when box.x == leftLimit, the image is panned to the left,\n      // i.e the current box is to the right of the initial viewbox,\n      // and only the right part of the initial image is visible, i.e.\n      // the right side of the initial viewbox minus left margin (viewbox.x+viewbox.width-left)\n      // is aligned with the left side of the viewport (box.x + viewportLeftOffset):\n      // viewbox.width + viewbox.x - left = box.x + viewportLeftOffset\n      // viewbox.width + viewbox.x - left - viewportLeftOffset = box.x (= leftLimit)\n      const leftLimit = viewbox.width + viewbox.x - left - viewportLeftOffset\n      // when box.x == rightLimit, the image is panned to the right,\n      // i.e the current box is to the left of the initial viewbox\n      // and only the left part of the initial image is visible, i.e\n      // the left side of the initial viewbox plus right margin (viewbox.x + right)\n      // is aligned with the right side of the viewport (box.x + box.width + viewportRightOffset)\n      // viewbox.x + right = box.x + box.width + viewportRightOffset\n      // viewbox.x + right - box.width - viewportRightOffset = box.x (= rightLimit)\n      const rightLimit = viewbox.x + right - box.width - viewportRightOffset\n      // same with top and bottom\n      const topLimit = viewbox.height + viewbox.y - top - viewportTopOffset\n      const bottomLimit = viewbox.y + bottom - box.height - viewportBottomOffset\n\n      box.x = Math.min(leftLimit, Math.max(rightLimit, box.x)) // enforce rightLimit <= box.x <= leftLimit\n      box.y = Math.min(topLimit, Math.max(bottomLimit, box.y)) // enforce bottomLimit <= box.y <= topLimit\n      return box\n    }\n\n    const wheelZoom = function (ev) {\n      ev.preventDefault()\n\n      // When wheeling on a mouse,\n      // - chrome by default uses deltaY = 53, deltaMode = 0 (pixel)\n      // - firefox by default uses deltaY = 3, deltaMode = 1 (line)\n      // - chrome and firefox on windows after configuring \"One screen at a time\"\n      //   use deltaY = 1, deltaMode = 2 (screen)\n      //\n      // Note that when when wheeling on a touchpad, deltaY depends on how fast\n      // you swipe, but the deltaMode is still different between the browsers.\n      //\n      // Normalize everything so that zooming speed is approximately the same in all cases\n      let normalizedPixelDeltaY\n      switch (ev.deltaMode) {\n      case 1:\n        normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeLinePixels\n        break\n      case 2:\n        normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeScreenPixels\n        break\n      default:\n        // 0 (already pixels) or new mode (avoid crashing)\n        normalizedPixelDeltaY = ev.deltaY\n        break\n      }\n\n      let lvl = Math.pow(1 + zoomFactor, (-1 * normalizedPixelDeltaY) / 100) * this.zoom()\n      const p = this.point(ev.clientX, ev.clientY)\n\n      if (lvl > zoomMax) {\n        lvl = zoomMax\n      }\n\n      if (lvl < zoomMin) {\n        lvl = zoomMin\n      }\n\n      if (this.dispatch('zoom', { level: lvl, focus: p }).defaultPrevented) {\n        return this\n      }\n\n      this.zoom(lvl, p)\n\n      if (margins) {\n        const box = restrictToMargins(this.viewbox())\n        this.viewbox(box)\n      }\n    }\n\n    const pinchZoomStart = function (ev) {\n      lastTouches = normalizeEvent(ev)\n\n      // Start panning in case only one touch is found\n      if (lastTouches.length < 2) {\n        if (doPanning && oneFingerPan) {\n          panStart.call(this, ev)\n        }\n        return\n      }\n\n      // Stop panning for more than one touch\n      if (doPanning && oneFingerPan) {\n        panStop.call(this, ev)\n      }\n\n      // We call it so late, so the user is still able to scroll / reload the page via gesture\n      // In case oneFingerPan is not active\n      ev.preventDefault()\n\n      if (this.dispatch('pinchZoomStart', { event: ev }).defaultPrevented) {\n        return\n      }\n\n      this.off('touchstart.panZoom', pinchZoomStart)\n\n      zoomInProgress = true\n      on(document, 'touchmove.panZoom', pinchZoom, this, { passive: false })\n      on(document, 'touchend.panZoom', pinchZoomStop, this, { passive: false })\n    }\n\n    const pinchZoomStop = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n      if (currentTouches.length > 1) {\n        return\n      }\n\n      zoomInProgress = false\n\n      this.dispatch('pinchZoomEnd', { event: ev })\n\n      off(document, 'touchmove.panZoom', pinchZoom)\n      off(document, 'touchend.panZoom', pinchZoomStop)\n      this.on('touchstart.panZoom', pinchZoomStart)\n\n      if (currentTouches.length && doPanning && oneFingerPan) {\n        panStart.call(this, ev)\n      }\n    }\n\n    const pinchZoom = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n      const zoom = this.zoom()\n\n      // Distance Formula\n      const lastDelta = Math.sqrt(\n        Math.pow(lastTouches[0].clientX - lastTouches[1].clientX, 2) +\n          Math.pow(lastTouches[0].clientY - lastTouches[1].clientY, 2)\n      )\n\n      const currentDelta = Math.sqrt(\n        Math.pow(currentTouches[0].clientX - currentTouches[1].clientX, 2) +\n          Math.pow(currentTouches[0].clientY - currentTouches[1].clientY, 2)\n      )\n\n      let zoomAmount = lastDelta / currentDelta\n\n      if (\n        (zoom < zoomMin && zoomAmount > 1) ||\n        (zoom > zoomMax && zoomAmount < 1)\n      ) {\n        zoomAmount = 1\n      }\n\n      const currentFocus = {\n        x:\n          currentTouches[0].clientX +\n          0.5 * (currentTouches[1].clientX - currentTouches[0].clientX),\n        y:\n          currentTouches[0].clientY +\n          0.5 * (currentTouches[1].clientY - currentTouches[0].clientY)\n      }\n\n      const lastFocus = {\n        x:\n          lastTouches[0].clientX +\n          0.5 * (lastTouches[1].clientX - lastTouches[0].clientX),\n        y:\n          lastTouches[0].clientY +\n          0.5 * (lastTouches[1].clientY - lastTouches[0].clientY)\n      }\n\n      const p = this.point(currentFocus.x, currentFocus.y)\n      const focusP = this.point(\n        2 * currentFocus.x - lastFocus.x,\n        2 * currentFocus.y - lastFocus.y\n      )\n      const box = new Box(this.viewbox()).transform(\n        new Matrix()\n          .translate(-focusP.x, -focusP.y)\n          .scale(zoomAmount, 0, 0)\n          .translate(p.x, p.y)\n      )\n\n      restrictToMargins(box)\n      this.viewbox(box)\n\n      lastTouches = currentTouches\n\n      this.dispatch('zoom', { box: box, focus: focusP })\n    }\n\n    const panStart = function (ev) {\n      const isMouse = ev.type.indexOf('mouse') > -1\n\n      // In case panStart is called with touch, ev.button is undefined\n      if (isMouse && ev.button !== panButton && ev.which !== panButton + 1) {\n        return\n      }\n\n      ev.preventDefault()\n\n      this.off('mousedown.panZoom', panStart)\n\n      lastTouches = normalizeEvent(ev)\n\n      if (zoomInProgress) return\n\n      this.dispatch('panStart', { event: ev })\n\n      lastP = { x: lastTouches[0].clientX, y: lastTouches[0].clientY }\n\n      on(document, 'touchmove.panZoom mousemove.panZoom', panning, this, {\n        passive: false\n      })\n\n      on(document, 'touchend.panZoom mouseup.panZoom', panStop, this, {\n        passive: false\n      })\n    }\n\n    const panStop = function (ev) {\n      ev.preventDefault()\n\n      off(document, 'touchmove.panZoom mousemove.panZoom', panning)\n      off(document, 'touchend.panZoom mouseup.panZoom', panStop)\n      this.on('mousedown.panZoom', panStart)\n\n      this.dispatch('panEnd', { event: ev })\n    }\n\n    const panning = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n\n      const currentP = {\n        x: currentTouches[0].clientX,\n        y: currentTouches[0].clientY\n      }\n\n      const p1 = this.point(currentP.x, currentP.y)\n\n      const p2 = this.point(lastP.x, lastP.y)\n\n      const deltaP = [p2.x - p1.x, p2.y - p1.y]\n\n      if (!deltaP[0] && !deltaP[1]) {\n        return\n      }\n\n      const box = new Box(this.viewbox()).transform(\n        new Matrix().translate(deltaP[0], deltaP[1])\n      )\n\n      lastP = currentP\n\n      restrictToMargins(box)\n\n      if (this.dispatch('panning', { box, event: ev }).defaultPrevented) {\n        return\n      }\n\n      this.viewbox(box)\n    }\n\n    if (doWheelZoom) {\n      this.on('wheel.panZoom', wheelZoom, this, { passive: false })\n    }\n\n    if (doPinchZoom) {\n      this.on('touchstart.panZoom', pinchZoomStart, this, { passive: false })\n    }\n\n    if (doPanning) {\n      this.on('mousedown.panZoom', panStart, this, { passive: false })\n    }\n\n    return this\n  }\n})\n"],
  "mappings": ";;;;;;;;;;;AAEA,IAAMA,iBAAiB,SAAjBA,gBAAiBC,IAAE;AAAA,SACvBA,GAAGC,WAAW,CAAC;IAAEC,SAASF,GAAGE;IAASC,SAASH,GAAGG;EAAnC,CAAD;AADS;AAGzBC,OAAOC,KAAK;EACVC,SADU,SAAA,QACDC,SAAS;AAAA,QAAA,UAAA,qBAAA,kBAAA,kBAAA,oBAAA,oBAAA,kBAAA,oBAAA,uBAAA,kBAAA,uBAAA,wBAAA,QAAA;AAChB,SAAKC,IAAI,UAAT;AAGA,QAAID,YAAY;AAAO,aAAO;AAE9BA,eAAO,WAAGA,YAAH,OAAA,WAAc,CAAA;AACrB,QAAME,cAAU,sBAAGF,QAAQE,eAAX,OAAA,sBAAyB;AACzC,QAAMC,WAAO,mBAAGH,QAAQG,YAAX,OAAA,mBAAsBC,OAAOC;AAC1C,QAAMC,WAAO,mBAAGN,QAAQM,YAAX,OAAA,mBAAsBF,OAAOG;AAC1C,QAAMC,eAAW,qBAAGR,QAAQS,cAAX,OAAA,qBAAwB;AACzC,QAAMC,eAAW,qBAAGV,QAAQW,cAAX,OAAA,qBAAwB;AACzC,QAAMC,aAAS,mBAAGZ,QAAQa,YAAX,OAAA,mBAAsB;AACrC,QAAMC,aAAS,qBAAGd,QAAQc,cAAX,OAAA,qBAAwB;AACvC,QAAMC,gBAAY,wBAAGf,QAAQe,iBAAX,OAAA,wBAA2B;AAC7C,QAAMC,WAAO,mBAAGhB,QAAQgB,YAAX,OAAA,mBAAsB;AACnC,QAAMC,gCAA4B,wBAAGjB,QAAQiB,iCAAX,OAAA,wBAA2C;AAC7E,QAAMC,kCAA8B,yBAAGlB,QAAQkB,mCAAX,OAAA,yBAA6C;AAEjF,QAAIC;AACJ,QAAIC;AACJ,QAAIC,iBAAiB;AAErB,QAAMC,UAAU,KAAKA,QAAL;AAEhB,QAAMC,oBAAoB,SAApBA,mBAAoBC,KAAO;AAC/B,UAAI,CAACR;AAAS,eAAOQ;AADU,UAEvBC,MAA6BT,QAA7BS,KAAKC,OAAwBV,QAAxBU,MAAMC,SAAkBX,QAAlBW,QAAQC,QAAUZ,QAAVY;AAFI,UAAA,aAIL,MAAKC,KAAK,CAAC,SAAS,QAAV,CAAV,GAAlBC,QAJuB,WAIvBA,OAAOC,SAJgB,WAIhBA;AACf,UAAMC,sBAAsB,MAAKC,KAAKD,oBAAoBE;AAM1D,UAAIC,qBAAqB;AACzB,UAAIC,sBAAsB;AAC1B,UAAIC,oBAAoB;AACxB,UAAIC,uBAAuB;AAG3B,UAAIN,oBAAoBO,UAAUP,oBAAoBQ,8BAA8B;AAClF,YAAMC,iBAAiBX,QAAQC;AAC/B,YAAMW,qBAAqBpB,QAAQQ,QAAQR,QAAQS;AAEnD,YAAIW,uBAAuBD,gBAAgB;AAEzC,cAAME,SAASX,oBAAoBY,gBAAgBZ,oBAAoBa;AACvE,cAAMC,cAAcL,iBAAiBC,qBAAqB,UAAU;AACpE,cAAMK,UAAUD,gBAAgB;AAChC,cAAME,mBAAoBL,UAAUI,WAAa,CAACJ,UAAU,CAACI;AAC7D,cAAME,QAAQD,mBACVP,iBAAiBC,qBACjBA,qBAAqBD;AAEzB,cAAMS,SAAS1B,IAAIsB,WAAD,IAAgBtB,IAAIsB,WAAD,IAAgBG;AACrD,cAAID,kBAAkB;AACpB,gBACEhB,oBAAoBO,UAAUP,oBAAoBmB,oCAClDnB,oBAAoBO,UAAUP,oBAAoBoB,oCAClDpB,oBAAoBO,UAAUP,oBAAoBqB,kCAAkC;AACpFlB,mCAAqBe,SAAS;AAC9Bd,oCAAsB,CAACc,SAAS;YACjC,WACClB,oBAAoBO,UAAUP,oBAAoBsB,oCAClDtB,oBAAoBO,UAAUP,oBAAoBuB,oCAClDvB,oBAAoBO,UAAUP,oBAAoBwB,kCAAkC;AACpFpB,oCAAsB,CAACc;YACxB,WACClB,oBAAoBO,UAAUP,oBAAoByB,oCAClDzB,oBAAoBO,UAAUP,oBAAoB0B,oCAClD1B,oBAAoBO,UAAUP,oBAAoB2B,kCAAkC;AACpFxB,mCAAqBe;YACtB;UACF,OAAM;AACL,gBACElB,oBAAoBO,UAAUP,oBAAoBuB,oCAClDvB,oBAAoBO,UAAUP,oBAAoBoB,oCAClDpB,oBAAoBO,UAAUP,oBAAoB0B,kCAAkC;AACpFrB,kCAAoBa,SAAS;AAC7BZ,qCAAuB,CAACY,SAAS;YAClC,WACClB,oBAAoBO,UAAUP,oBAAoBsB,oCAClDtB,oBAAoBO,UAAUP,oBAAoBmB,oCAClDnB,oBAAoBO,UAAUP,oBAAoByB,kCAAkC;AACpFnB,qCAAuB,CAACY;YACzB,WACClB,oBAAoBO,UAAUP,oBAAoBwB,oCAClDxB,oBAAoBO,UAAUP,oBAAoBqB,oCAClDrB,oBAAoBO,UAAUP,oBAAoB2B,kCAAkC;AACpFtB,kCAAoBa;YACrB;UACF;QAEF;MACF;AASD,UAAMU,YAAYtC,QAAQQ,QAAQR,QAAQuC,IAAInC,OAAOS;AAQrD,UAAM2B,aAAaxC,QAAQuC,IAAIjC,QAAQJ,IAAIM,QAAQM;AAEnD,UAAM2B,WAAWzC,QAAQS,SAAST,QAAQ0C,IAAIvC,MAAMY;AACpD,UAAM4B,cAAc3C,QAAQ0C,IAAIrC,SAASH,IAAIO,SAASO;AAEtDd,UAAIqC,IAAIK,KAAKC,IAAIP,WAAWM,KAAKE,IAAIN,YAAYtC,IAAIqC,CAAzB,CAApB;AACRrC,UAAIwC,IAAIE,KAAKC,IAAIJ,UAAUG,KAAKE,IAAIH,aAAazC,IAAIwC,CAA1B,CAAnB;AACR,aAAOxC;IACR;AAED,QAAMf,YAAY,SAAZA,WAAsBhB,IAAI;AAC9BA,SAAG4E,eAAH;AAYA,UAAIC;AACJ,cAAQ7E,GAAG8E,WAAX;QACA,KAAK;AACHD,kCAAwB7E,GAAG+E,SAASvD;AACpC;QACF,KAAK;AACHqD,kCAAwB7E,GAAG+E,SAAStD;AACpC;QACF;AAEEoD,kCAAwB7E,GAAG+E;AAC3B;MAVF;AAaA,UAAIC,MAAMP,KAAKQ,IAAI,IAAIxE,YAAa,KAAKoE,wBAAyB,GAAxD,IAA+D,KAAKK,KAAL;AACzE,UAAMC,IAAI,KAAKC,MAAMpF,GAAGE,SAASF,GAAGG,OAA1B;AAEV,UAAI6E,MAAMnE,SAAS;AACjBmE,cAAMnE;MACP;AAED,UAAImE,MAAMtE,SAAS;AACjBsE,cAAMtE;MACP;AAED,UAAI,KAAK2E,SAAS,QAAQ;QAAEC,OAAON;QAAKO,OAAOJ;MAArB,CAAtB,EAAgDK,kBAAkB;AACpE,eAAO;MACR;AAED,WAAKN,KAAKF,KAAKG,CAAf;AAEA,UAAI5D,SAAS;AACX,YAAMQ,MAAMD,kBAAkB,KAAKD,QAAL,CAAD;AAC7B,aAAKA,QAAQE,GAAb;MACD;IACF;AAED,QAAM0D,iBAAiB,SAAjBA,gBAA2BzF,IAAI;AACnC2B,oBAAc5B,eAAeC,EAAD;AAG5B,UAAI2B,YAAY+D,SAAS,GAAG;AAC1B,YAAIvE,aAAaG,cAAc;AAC7BqE,mBAASC,KAAK,MAAM5F,EAApB;QACD;AACD;MACD;AAGD,UAAImB,aAAaG,cAAc;AAC7BuE,gBAAQD,KAAK,MAAM5F,EAAnB;MACD;AAIDA,SAAG4E,eAAH;AAEA,UAAI,KAAKS,SAAS,kBAAkB;QAAES,OAAO9F;MAAT,CAAhC,EAA+CwF,kBAAkB;AACnE;MACD;AAED,WAAKhF,IAAI,sBAAsBiF,eAA/B;AAEA7D,uBAAiB;AACjBmE,SAAGC,UAAU,qBAAqB9E,WAAW,MAAM;QAAE+E,SAAS;MAAX,CAAjD;AACFF,SAAGC,UAAU,oBAAoBE,eAAe,MAAM;QAAED,SAAS;MAAX,CAApD;IACH;AAED,QAAMC,gBAAgB,SAAhBA,eAA0BlG,IAAI;AAClCA,SAAG4E,eAAH;AAEA,UAAMuB,iBAAiBpG,eAAeC,EAAD;AACrC,UAAImG,eAAeT,SAAS,GAAG;AAC7B;MACD;AAED9D,uBAAiB;AAEjB,WAAKyD,SAAS,gBAAgB;QAAES,OAAO9F;MAAT,CAA9B;AAEAQ,UAAIwF,UAAU,qBAAqB9E,SAAhC;AACHV,UAAIwF,UAAU,oBAAoBE,cAA/B;AACH,WAAKH,GAAG,sBAAsBN,cAA9B;AAEA,UAAIU,eAAeT,UAAUvE,aAAaG,cAAc;AACtDqE,iBAASC,KAAK,MAAM5F,EAApB;MACD;IACF;AAED,QAAMkB,YAAY,SAAZA,WAAsBlB,IAAI;AAC9BA,SAAG4E,eAAH;AAEA,UAAMuB,iBAAiBpG,eAAeC,EAAD;AACrC,UAAMkF,OAAO,KAAKA,KAAL;AAGb,UAAMkB,YAAY3B,KAAK4B,KACrB5B,KAAKQ,IAAItD,YAAY,CAAD,EAAIzB,UAAUyB,YAAY,CAAD,EAAIzB,SAAS,CAA1D,IACEuE,KAAKQ,IAAItD,YAAY,CAAD,EAAIxB,UAAUwB,YAAY,CAAD,EAAIxB,SAAS,CAA1D,CAFc;AAKlB,UAAMmG,eAAe7B,KAAK4B,KACxB5B,KAAKQ,IAAIkB,eAAe,CAAD,EAAIjG,UAAUiG,eAAe,CAAD,EAAIjG,SAAS,CAAhE,IACEuE,KAAKQ,IAAIkB,eAAe,CAAD,EAAIhG,UAAUgG,eAAe,CAAD,EAAIhG,SAAS,CAAhE,CAFiB;AAKrB,UAAIoG,aAAaH,YAAYE;AAE7B,UACGpB,OAAOxE,WAAW6F,aAAa,KAC/BrB,OAAOrE,WAAW0F,aAAa,GAChC;AACAA,qBAAa;MACd;AAED,UAAMC,eAAe;QACnBpC,GACE+B,eAAe,CAAD,EAAIjG,UAClB,OAAOiG,eAAe,CAAD,EAAIjG,UAAUiG,eAAe,CAAD,EAAIjG;QACvDqE,GACE4B,eAAe,CAAD,EAAIhG,UAClB,OAAOgG,eAAe,CAAD,EAAIhG,UAAUgG,eAAe,CAAD,EAAIhG;MANpC;AASrB,UAAMsG,YAAY;QAChBrC,GACEzC,YAAY,CAAD,EAAIzB,UACf,OAAOyB,YAAY,CAAD,EAAIzB,UAAUyB,YAAY,CAAD,EAAIzB;QACjDqE,GACE5C,YAAY,CAAD,EAAIxB,UACf,OAAOwB,YAAY,CAAD,EAAIxB,UAAUwB,YAAY,CAAD,EAAIxB;MANjC;AASlB,UAAMgF,IAAI,KAAKC,MAAMoB,aAAapC,GAAGoC,aAAajC,CAAxC;AACV,UAAMmC,SAAS,KAAKtB,MAClB,IAAIoB,aAAapC,IAAIqC,UAAUrC,GAC/B,IAAIoC,aAAajC,IAAIkC,UAAUlC,CAFlB;AAIf,UAAMxC,MAAM,IAAI4E,IAAI,KAAK9E,QAAL,CAAR,EAAwB+E,UAClC,IAAIC,OAAJ,EACGC,UAAU,CAACJ,OAAOtC,GAAG,CAACsC,OAAOnC,CADhC,EAEGwC,MAAMR,YAAY,GAAG,CAFxB,EAGGO,UAAU3B,EAAEf,GAAGe,EAAEZ,CAHpB,CADU;AAOZzC,wBAAkBC,GAAD;AACjB,WAAKF,QAAQE,GAAb;AAEAJ,oBAAcwE;AAEd,WAAKd,SAAS,QAAQ;QAAEtD;QAAUwD,OAAOmB;MAAnB,CAAtB;IACD;AAED,QAAMf,WAAW,SAAXA,UAAqB3F,IAAI;AAC7B,UAAMgH,UAAUhH,GAAGiH,KAAKC,QAAQ,OAAhB,IAA2B;AAG3C,UAAIF,WAAWhH,GAAGmH,WAAW9F,aAAarB,GAAGoH,UAAU/F,YAAY,GAAG;AACpE;MACD;AAEDrB,SAAG4E,eAAH;AAEA,WAAKpE,IAAI,qBAAqBmF,SAA9B;AAEAhE,oBAAc5B,eAAeC,EAAD;AAE5B,UAAI4B;AAAgB;AAEpB,WAAKyD,SAAS,YAAY;QAAES,OAAO9F;MAAT,CAA1B;AAEA0B,cAAQ;QAAE0C,GAAGzC,YAAY,CAAD,EAAIzB;QAASqE,GAAG5C,YAAY,CAAD,EAAIxB;MAA/C;AAER4F,SAAGC,UAAU,uCAAuC5E,SAAS,MAAM;QACjE6E,SAAS;MADwD,CAAjE;AAIFF,SAAGC,UAAU,oCAAoCH,SAAS,MAAM;QAC9DI,SAAS;MADqD,CAA9D;IAGH;AAED,QAAMJ,UAAU,SAAVA,SAAoB7F,IAAI;AAC5BA,SAAG4E,eAAH;AAEApE,UAAIwF,UAAU,uCAAuC5E,OAAlD;AACHZ,UAAIwF,UAAU,oCAAoCH,QAA/C;AACH,WAAKE,GAAG,qBAAqBJ,QAA7B;AAEA,WAAKN,SAAS,UAAU;QAAES,OAAO9F;MAAT,CAAxB;IACD;AAED,QAAMoB,UAAU,SAAVA,SAAoBpB,IAAI;AAC5BA,SAAG4E,eAAH;AAEA,UAAMuB,iBAAiBpG,eAAeC,EAAD;AAErC,UAAMqH,WAAW;QACfjD,GAAG+B,eAAe,CAAD,EAAIjG;QACrBqE,GAAG4B,eAAe,CAAD,EAAIhG;MAFN;AAKjB,UAAMmH,KAAK,KAAKlC,MAAMiC,SAASjD,GAAGiD,SAAS9C,CAAhC;AAEX,UAAMgD,KAAK,KAAKnC,MAAM1D,MAAM0C,GAAG1C,MAAM6C,CAA1B;AAEX,UAAMiD,SAAS,CAACD,GAAGnD,IAAIkD,GAAGlD,GAAGmD,GAAGhD,IAAI+C,GAAG/C,CAAxB;AAEf,UAAI,CAACiD,OAAO,CAAD,KAAO,CAACA,OAAO,CAAD,GAAK;AAC5B;MACD;AAED,UAAMzF,MAAM,IAAI4E,IAAI,KAAK9E,QAAL,CAAR,EAAwB+E,UAClC,IAAIC,OAAJ,EAAaC,UAAUU,OAAO,CAAD,GAAKA,OAAO,CAAD,CAAxC,CADU;AAIZ9F,cAAQ2F;AAERvF,wBAAkBC,GAAD;AAEjB,UAAI,KAAKsD,SAAS,WAAW;QAAEtD;QAAK+D,OAAO9F;MAAd,CAAzB,EAA6CwF,kBAAkB;AACjE;MACD;AAED,WAAK3D,QAAQE,GAAb;IACD;AAED,QAAIhB,aAAa;AACf,WAAKgF,GAAG,iBAAiB/E,WAAW,MAAM;QAAEiF,SAAS;MAAX,CAA1C;IACD;AAED,QAAIhF,aAAa;AACf,WAAK8E,GAAG,sBAAsBN,gBAAgB,MAAM;QAAEQ,SAAS;MAAX,CAApD;IACD;AAED,QAAI9E,WAAW;AACb,WAAK4E,GAAG,qBAAqBJ,UAAU,MAAM;QAAEM,SAAS;MAAX,CAA7C;IACD;AAED,WAAO;EACR;AAzXS,CAAN;",
  "names": ["normalizeEvent", "ev", "touches", "clientX", "clientY", "extend", "Svg", "panZoom", "options", "off", "zoomFactor", "zoomMin", "Number", "MIN_VALUE", "zoomMax", "MAX_VALUE", "doWheelZoom", "wheelZoom", "doPinchZoom", "pinchZoom", "doPanning", "panning", "panButton", "oneFingerPan", "margins", "wheelZoomDeltaModeLinePixels", "wheelZoomDeltaModeScreenPixels", "lastP", "lastTouches", "zoomInProgress", "viewbox", "restrictToMargins", "box", "top", "left", "bottom", "right", "attr", "width", "height", "preserveAspectRatio", "node", "baseVal", "viewportLeftOffset", "viewportRightOffset", "viewportTopOffset", "viewportBottomOffset", "align", "SVG_PRESERVEASPECTRATIO_NONE", "svgAspectRatio", "viewboxAspectRatio", "isMeet", "meetOrSlice", "SVG_MEETORSLICE_SLICE", "changedAxis", "isWidth", "changeHorizontal", "ratio", "offset", "SVG_PRESERVEASPECTRATIO_XMIDYMIN", "SVG_PRESERVEASPECTRATIO_XMIDYMID", "SVG_PRESERVEASPECTRATIO_XMIDYMAX", "SVG_PRESERVEASPECTRATIO_XMINYMIN", "SVG_PRESERVEASPECTRATIO_XMINYMID", "SVG_PRESERVEASPECTRATIO_XMINYMAX", "SVG_PRESERVEASPECTRATIO_XMAXYMIN", "SVG_PRESERVEASPECTRATIO_XMAXYMID", "SVG_PRESERVEASPECTRATIO_XMAXYMAX", "leftLimit", "x", "rightLimit", "topLimit", "y", "bottomLimit", "Math", "min", "max", "preventDefault", "normalizedPixelDeltaY", "deltaMode", "deltaY", "lvl", "pow", "zoom", "p", "point", "dispatch", "level", "focus", "defaultPrevented", "pinchZoomStart", "length", "panStart", "call", "panStop", "event", "on", "document", "passive", "pinchZoomStop", "currentTouches", "lastDelta", "sqrt", "currentDelta", "zoomAmount", "currentFocus", "lastFocus", "focusP", "Box", "transform", "Matrix", "translate", "scale", "isMouse", "type", "indexOf", "button", "which", "currentP", "p1", "p2", "deltaP"]
}
